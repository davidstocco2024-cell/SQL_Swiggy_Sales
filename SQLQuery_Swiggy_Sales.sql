/*
================================================================================
  PROJECT      : Swiggy Data Analysis - End-to-End SQL Pipeline
  DATABASE     : Swiggy_Data (dbo)
  AUTHOR       : David Stocco
  CREATED      : 2026-02-10
  DESCRIPTION  : Complete SQL workflow covering Data Cleaning, Star Schema
                 implementation, ETL pipeline, and Business Intelligence KPIs
                 for Swiggy food delivery analytics.

  TABLE OF CONTENTS:
  ??????????????????????????????????????????????????????????????????????????
  SECTION 01 — DATA CLEANING & QUALITY ASSURANCE
    01.1  Total Row Count
    01.2  Null Value Assessment
    01.3  Blank/Empty String Detection
    01.4  Duplicate Analysis
    01.5  Duplicate Removal
    01.6  Outlier Detection
    01.7  Data Normalization

  SECTION 02 — DIMENSIONAL MODELING (STAR SCHEMA)
    02.1  Dimension Tables Creation
    02.2  Fact Table Creation
    02.3  ETL: Populating Dimensions
    02.4  ETL: Populating Fact Table

  SECTION 03 — BUSINESS INTELLIGENCE & KPI DEVELOPMENT
    03.1  Core Metrics
    03.2  Temporal Trends
    03.3  Geographic & Restaurant Performance
    03.4  Cuisine & Dish Insights
    03.5  Customer Spending Buckets
    03.6  Rating Distribution Analysis

  SECTION 04 — INTERMEDIATE ANALYSIS (TIER 2)
    04.1  Restaurant Performance Scorecard
    04.2  Category Profitability Analysis
    04.3  City-Level Market Share
    04.4  Peak Ordering Hours Analysis
    04.5  Customer Retention by Restaurant
    04.6  Price vs Rating Correlation
    04.7  Top Performing Dishes by Revenue
    04.8  Geographic Expansion Opportunities
    04.9  Restaurant Rating Volatility
    04.10 Monthly Growth Rate Analysis
================================================================================
*/


-- ============================================================================
-- SECTION 01: DATA CLEANING & QUALITY ASSURANCE
-- ============================================================================
-- Purpose: Profile raw data, detect quality issues, remove duplicates,
--          and normalize invalid values before dimensional modeling.
-- ============================================================================


-- ????????????????????????????????????????????????????????????????????????????
-- [01.1] Total Row Count
-- ????????????????????????????????????????????????????????????????????????????
-- Establishes baseline data volume for subsequent quality checks.
-- Used to calculate null percentages and validate ETL completeness.

SELECT COUNT(*) AS total_rows 
FROM dbo.Swiggy_Data;


-- ????????????????????????????????????????????????????????????????????????????
-- [01.2] Null Value Assessment
-- ????????????????????????????????????????????????????????????????????????????
-- Counts NULL values across all critical columns.
-- High null counts in key fields (State, Restaurant_Name, Price_INR) require
-- either imputation or row exclusion during ETL to prevent fact table gaps.

SELECT 
      SUM(CASE WHEN State IS NULL THEN 1 ELSE 0 END)           AS null_state
    , SUM(CASE WHEN City IS NULL THEN 1 ELSE 0 END)            AS null_city
    , SUM(CASE WHEN Order_Date IS NULL THEN 1 ELSE 0 END)      AS null_order_date
    , SUM(CASE WHEN Restaurant_Name IS NULL THEN 1 ELSE 0 END) AS null_restaurant_name
    , SUM(CASE WHEN Location IS NULL THEN 1 ELSE 0 END)        AS null_location
    , SUM(CASE WHEN Category IS NULL THEN 1 ELSE 0 END)        AS null_category
    , SUM(CASE WHEN Dish_Name IS NULL THEN 1 ELSE 0 END)       AS null_dish_name
    , SUM(CASE WHEN Price_INR IS NULL THEN 1 ELSE 0 END)       AS null_price_inr
    , SUM(CASE WHEN Rating IS NULL THEN 1 ELSE 0 END)          AS null_rating
    , SUM(CASE WHEN Rating_Count IS NULL THEN 1 ELSE 0 END)    AS null_rating_count
FROM dbo.Swiggy_Data;


-- ????????????????????????????????????????????????????????????????????????????
-- [01.3] Blank/Empty String Detection
-- ????????????????????????????????????????????????????????????????????????????
-- Detects empty strings ('') which are distinct from NULL but equally invalid.
-- Common issue when importing CSV files with missing values rendered as "".
-- Rows with blank strings should be excluded or corrected in ETL.

SELECT 
      SUM(CASE WHEN State = '' THEN 1 ELSE 0 END)              AS blank_state
    , SUM(CASE WHEN City = '' THEN 1 ELSE 0 END)               AS blank_city
    , SUM(CASE WHEN Restaurant_Name = '' THEN 1 ELSE 0 END)    AS blank_restaurant_name
    , SUM(CASE WHEN Location = '' THEN 1 ELSE 0 END)           AS blank_location
    , SUM(CASE WHEN Category = '' THEN 1 ELSE 0 END)           AS blank_category
    , SUM(CASE WHEN Dish_Name = '' THEN 1 ELSE 0 END)          AS blank_dish_name    
FROM dbo.Swiggy_Data;


-- ????????????????????????????????????????????????????????????????????????????
-- [01.4] Duplicate Analysis
-- ????????????????????????????????????????????????????????????????????????????
-- Identifies exact duplicate rows across all composite key columns.
-- Duplicates inflate metrics like order count and revenue, causing incorrect KPIs.
-- HAVING COUNT(*) > 1 filters to only show rows with 2+ identical copies.

SELECT 
      State
    , City
    , Order_Date
    , Restaurant_Name
    , Location
    , Category
    , Dish_Name
    , Price_INR
    , COUNT(*) AS duplicate_count
FROM dbo.Swiggy_Data
GROUP BY 
      State
    , City
    , Order_Date
    , Restaurant_Name
    , Location
    , Category
    , Dish_Name
    , Price_INR
HAVING COUNT(*) > 1
ORDER BY duplicate_count DESC;


-- ????????????????????????????????????????????????????????????????????????????
-- [01.5] Duplicate Removal (CTE + ROW_NUMBER)
-- ????????????????????????????????????????????????????????????????????????????
-- Deletes duplicate rows while preserving one copy of each unique record.
-- ROW_NUMBER() assigns sequential numbers within each duplicate group.
-- Rows with rn > 1 are redundant copies and are deleted.
-- PARTITION BY defines what constitutes a "duplicate" (all 8 columns identical).

WITH CTE AS (
    SELECT *
        , ROW_NUMBER() OVER (
            PARTITION BY 
                  State
                , City
                , Order_Date
                , Restaurant_Name
                , Location
                , Category
                , Dish_Name
                , Price_INR 
            ORDER BY (SELECT NULL)
        ) AS rn
    FROM dbo.Swiggy_Data
)    
DELETE FROM CTE WHERE rn > 1;


-- ????????????????????????????????????????????????????????????????????????????
-- [01.6] Outlier Detection
-- ????????????????????????????????????????????????????????????????????????????
-- Checks min/max ranges for numeric columns to detect invalid or extreme values.
-- Valid ranges: Price_INR > 0, Rating between 0–5, Rating_Count >= 0.
-- Outliers outside these bounds indicate data entry errors or system bugs.

SELECT 
      MIN(Price_INR)    AS min_price
    , MAX(Price_INR)    AS max_price
    , MIN(Rating)       AS min_rating
    , MAX(Rating)       AS max_rating
    , MIN(Rating_Count) AS min_count
    , MAX(Rating_Count) AS max_count
FROM dbo.Swiggy_Data;


-- ????????????????????????????????????????????????????????????????????????????
-- [01.7] Data Normalization
-- ????????????????????????????????????????????????????????????????????????????
-- Sets invalid Rating values (< 0 or > 5) to NULL to prevent skewed averages.
-- Alternative: Delete rows entirely if Rating is a mandatory field.
-- Prevents corrupt data from propagating into fact table and KPI calculations.

UPDATE dbo.Swiggy_Data
SET Rating = NULL
WHERE Rating < 0 OR Rating > 5;


-- ============================================================================
-- SECTION 02: DIMENSIONAL MODELING (STAR SCHEMA)
-- ============================================================================
-- Purpose: Create normalized dimension and fact tables, then populate via ETL.
-- Star schema separates descriptive attributes (dimensions) from
-- transactional metrics (facts) for efficient querying and BI analysis.
-- ============================================================================


-- ????????????????????????????????????????????????????????????????????????????
-- [02.1] Dimension Tables Creation
-- ????????????????????????????????????????????????????????????????????????????
-- Creates five dimension tables (Date, Location, Restaurant, Category, Dish).
-- Each dimension stores unique attribute values referenced by the fact table.
-- IDENTITY(1,1) generates surrogate keys automatically on INSERT.

CREATE TABLE dim_date (
      date_id     INT IDENTITY(1,1) PRIMARY KEY 
    , FULL_DATE   DATE
    , YEAR        INT
    , MONTH       INT
    , Month_Name  VARCHAR(20)
    , Quarter     INT
    , DAY         INT
    , WEEK        INT
);

CREATE TABLE dim_location (
      location_id INT IDENTITY(1,1) PRIMARY KEY
    , State       VARCHAR(100)
    , City        VARCHAR(100)
    , Location    VARCHAR(200)
);

CREATE TABLE dim_restaurant (
      restaurant_id   INT IDENTITY(1,1) PRIMARY KEY
    , restaurant_name VARCHAR(200)
);

CREATE TABLE dim_category (
      category_id INT IDENTITY(1,1) PRIMARY KEY
    , category    VARCHAR(200)
);

CREATE TABLE dim_dish (
      dish_id   INT IDENTITY(1,1) PRIMARY KEY
    , dish_name VARCHAR(200)
);


-- ????????????????????????????????????????????????????????????????????????????
-- [02.2] Fact Table Creation
-- ????????????????????????????????????????????????????????????????????????????
-- Central table storing transactional metrics (price, rating, rating_count).
-- Foreign keys link to dimension tables for denormalized analysis.
-- Each row represents one dish order with full dimensional context.

CREATE TABLE fact_swiggy_orders (
      order_id      INT IDENTITY(1,1) PRIMARY KEY
    , date_id       INT
    , price_INR     DECIMAL(10,2)
    , rating        DECIMAL(4,2)
    , rating_count  INT
    , location_id   INT
    , restaurant_id INT
    , category_id   INT
    , dish_id       INT
    , FOREIGN KEY (date_id)       REFERENCES dim_date(date_id)
    , FOREIGN KEY (location_id)   REFERENCES dim_location(location_id)
    , FOREIGN KEY (restaurant_id) REFERENCES dim_restaurant(restaurant_id)
    , FOREIGN KEY (category_id)   REFERENCES dim_category(category_id)
    , FOREIGN KEY (dish_id)       REFERENCES dim_dish(dish_id)
);


-- ????????????????????????????????????????????????????????????????????????????
-- [02.3] ETL: Populating Dimensions
-- ????????????????????????????????????????????????????????????????????????????
-- Extracts DISTINCT values from raw data and loads into dimension tables.
-- Date dimension includes calculated fields (YEAR, Month_Name, Quarter, etc.).
-- WHERE NOT NULL filters prevent inserting invalid dimension records.

-- Date Dimension
INSERT INTO dim_date (FULL_DATE, YEAR, MONTH, Month_Name, Quarter, DAY, WEEK)
SELECT DISTINCT 
      Order_Date
    , YEAR(Order_Date)
    , MONTH(Order_Date)
    , DATENAME(MONTH, Order_Date)
    , DATEPART(QUARTER, Order_Date)
    , DAY(Order_Date)
    , DATEPART(WEEK, Order_Date)
FROM dbo.Swiggy_Data 
WHERE Order_Date IS NOT NULL;

-- Location Dimension
INSERT INTO dim_location (State, City, Location)
SELECT DISTINCT State, City, Location 
FROM dbo.Swiggy_Data
WHERE State    IS NOT NULL 
  AND City     IS NOT NULL 
  AND Location IS NOT NULL;

-- Restaurant Dimension
INSERT INTO dim_restaurant (restaurant_name)
SELECT DISTINCT Restaurant_Name 
FROM dbo.Swiggy_Data 
WHERE Restaurant_Name IS NOT NULL;

-- Category Dimension
INSERT INTO dim_category (category)
SELECT DISTINCT Category 
FROM dbo.Swiggy_Data 
WHERE Category IS NOT NULL;

-- Dish Dimension
INSERT INTO dim_dish (dish_name)
SELECT DISTINCT Dish_Name 
FROM dbo.Swiggy_Data 
WHERE Dish_Name IS NOT NULL;


-- ????????????????????????????????????????????????????????????????????????????
-- [02.4] ETL: Populating Fact Table
-- ????????????????????????????????????????????????????????????????????????????
-- Joins raw data to dimension tables to retrieve surrogate keys (IDs).
-- Inserts transactional metrics (price, rating, rating_count) with dimension FKs.
-- INNER JOINs ensure only fully-dimensional rows are loaded (no orphan facts).

INSERT INTO fact_swiggy_orders (
      date_id
    , price_INR
    , rating
    , rating_count
    , location_id
    , restaurant_id
    , category_id
    , dish_id
)
SELECT 
      d.date_id
    , s.Price_INR
    , s.Rating
    , s.Rating_Count
    , l.location_id
    , r.restaurant_id
    , c.category_id
    , di.dish_id
FROM dbo.Swiggy_Data s
INNER JOIN dim_date       d  ON s.Order_Date      = d.FULL_DATE
INNER JOIN dim_location   l  ON s.State           = l.State 
                             AND s.City            = l.City 
                             AND s.Location        = l.Location
INNER JOIN dim_restaurant r  ON s.Restaurant_Name = r.restaurant_name
INNER JOIN dim_category   c  ON s.Category        = c.category
INNER JOIN dim_dish       di ON s.Dish_Name       = di.dish_name
WHERE s.Order_Date      IS NOT NULL 
  AND s.Restaurant_Name IS NOT NULL 
  AND s.Category        IS NOT NULL;


-- ============================================================================
-- SECTION 03: BUSINESS INTELLIGENCE & KPI DEVELOPMENT
-- ============================================================================
-- Purpose: Analyze sales trends, customer behavior, and operational metrics.
-- Queries leverage star schema for fast aggregation across dimensions.
-- ============================================================================


-- ????????????????????????????????????????????????????????????????????????????
-- [03.1] Core Metrics
-- ????????????????????????????????????????????????????????????????????????????

-- Total Orders
-- Baseline metric for portfolio size and monthly growth rate calculations.
SELECT COUNT(*) AS total_orders 
FROM fact_swiggy_orders;

-- Total Revenue (in Millions INR)
-- Aggregate revenue formatted for executive reporting.
-- CONVERT(FLOAT, ...) prevents integer truncation in SUM aggregation.
SELECT FORMAT(SUM(CONVERT(FLOAT, price_INR)) / 1000000, 'N2') + ' INR Million' AS total_revenue_million 
FROM fact_swiggy_orders;

-- Average Dish Price
-- Indicates typical customer spending per order item.
-- Used for pricing strategy and discount impact analysis.
SELECT FORMAT(AVG(CONVERT(FLOAT, price_INR)), 'N2') + ' INR' AS average_dish_price 
FROM fact_swiggy_orders;

-- Average Rating
-- Platform-wide customer satisfaction indicator.
-- Benchmark for restaurant performance comparison.
SELECT FORMAT(AVG(CONVERT(FLOAT, rating)), 'N2') AS average_rating 
FROM fact_swiggy_orders;


-- ????????????????????????????????????????????????????????????????????????????
-- [03.2] Temporal Trends
-- ????????????????????????????????????????????????????????????????????????????

-- Monthly Ordering Patterns
-- Identifies seasonal peaks (e.g., festivals, holidays, summer).
-- Orders sorted descending to highlight highest-volume months.
SELECT 
      d.YEAR
    , d.Month_Name
    , COUNT(*) AS monthly_orders
FROM fact_swiggy_orders f 
JOIN dim_date d ON f.date_id = d.date_id
GROUP BY d.YEAR, d.Month_Name 
ORDER BY monthly_orders DESC;

-- Day-of-Week Analysis
-- Reveals weekly patterns (e.g., weekend spikes, weekday lunch rushes).
-- Used to optimize delivery logistics and promotional timing.
SELECT 
      d.YEAR
    , DATENAME(WEEKDAY, d.FULL_DATE) AS day_of_week
    , COUNT(*) AS orders
FROM fact_swiggy_orders f 
JOIN dim_date d ON f.date_id = d.date_id
GROUP BY d.YEAR, d.Month_Name, DATENAME(WEEKDAY, d.FULL_DATE) 
ORDER BY orders DESC;


-- ????????????????????????????????????????????????????????????????????????????
-- [03.3] Geographic & Restaurant Performance
-- ????????????????????????????????????????????????????????????????????????????

-- Top 10 Cities by Order Volume
-- Identifies high-demand markets for expansion and resource allocation.
-- OFFSET/FETCH implements SQL Server pagination for top-N ranking.
SELECT 
      l.City
    , COUNT(*) AS order_volume
FROM fact_swiggy_orders f 
JOIN dim_location l ON f.location_id = l.location_id
GROUP BY l.City 
ORDER BY order_volume DESC 
OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY;

-- Top 10 Restaurants by Order Count
-- Highlights most popular vendors for partnership retention strategies.
-- High volume restaurants may qualify for featured placement or lower commissions.
SELECT 
      r.restaurant_name
    , COUNT(*) AS order_count
FROM fact_swiggy_orders f 
JOIN dim_restaurant r ON f.restaurant_id = r.restaurant_id
GROUP BY r.restaurant_name 
ORDER BY order_count DESC 
OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY;


-- ????????????????????????????????????????????????????????????????????????????
-- [03.4] Cuisine & Dish Insights
-- ????????????????????????????????????????????????????????????????????????????

-- Category Performance with Average Rating
-- Ranks cuisine types by order count and customer satisfaction.
-- Low-rated high-volume categories indicate quality improvement opportunities.
SELECT 
      c.category
    , COUNT(*) AS order_count
    , FORMAT(AVG(CONVERT(FLOAT, f.rating)), 'N2') AS average_rating
FROM fact_swiggy_orders f 
JOIN dim_category c ON f.category_id = c.category_id
GROUP BY c.category 
ORDER BY order_count DESC;


-- ????????????????????????????????????????????????????????????????????????????
-- [03.5] Customer Spending Buckets
-- ????????????????????????????????????????????????????????????????????????????
-- Segments orders by price tier to profile customer spending behavior.
-- Informs discount thresholds (e.g., "?100 off on ?300+") and upsell strategies.
-- CASE expression creates five mutually exclusive buckets from continuous price data.

SELECT 
    CASE 
        WHEN price_INR < 100                    THEN 'Under 100'
        WHEN price_INR >= 100 AND price_INR < 200 THEN '100–199'
        WHEN price_INR >= 200 AND price_INR < 300 THEN '200–299'
        WHEN price_INR >= 300 AND price_INR < 500 THEN '300–499'
        ELSE '500+'
    END AS spending_bucket,
    COUNT(*) AS order_count
FROM fact_swiggy_orders
GROUP BY 
    CASE 
        WHEN price_INR < 100                    THEN 'Under 100'
        WHEN price_INR >= 100 AND price_INR < 200 THEN '100–199'
        WHEN price_INR >= 200 AND price_INR < 300 THEN '200–299'
        WHEN price_INR >= 300 AND price_INR < 500 THEN '300–499'
        ELSE '500+'
    END
ORDER BY order_count DESC;


-- ????????????????????????????????????????????????????????????????????????????
-- [03.6] Rating Distribution Analysis
-- ????????????????????????????????????????????????????????????????????????????
-- Bins ratings into star categories (1-2?, 2-3?, 3-4?, 4-5?, 5?).
-- Skewed distribution toward lower ratings signals platform quality issues.
-- WHERE rating IS NOT NULL excludes unrated orders from percentage calculations.

SELECT 
    CASE 
        WHEN rating >= 1 AND rating < 2 THEN '1-1.99'
        WHEN rating >= 2 AND rating < 3 THEN '2-2.99'
        WHEN rating >= 3 AND rating < 4 THEN '3-3.99'
        WHEN rating >= 4 AND rating < 5 THEN '4-4.99'
        ELSE '5'
    END AS rating_bucket,
    COUNT(*) AS count
FROM fact_swiggy_orders
WHERE rating IS NOT NULL
GROUP BY
    CASE 
        WHEN rating >= 1 AND rating < 2 THEN '1-1.99'
        WHEN rating >= 2 AND rating < 3 THEN '2-2.99'
        WHEN rating >= 3 AND rating < 4 THEN '3-3.99'
        WHEN rating >= 4 AND rating < 5 THEN '4-4.99'
        ELSE '5'
    END
ORDER BY count DESC;


-- ============================================================================
-- SECTION 04: INTERMEDIATE ANALYSIS (TIER 2)
-- ============================================================================
-- Purpose: Advanced business insights using multi-table joins, 
-- conditional aggregations, and comparative analysis.
-- ============================================================================


-- ????????????????????????????????????????????????????????????????????????????
-- [04.1] Restaurant Performance Scorecard
-- ????????????????????????????????????????????????????????????????????????????
-- Combines volume, revenue, and customer satisfaction into a single view.
-- High revenue + low rating = quality issues; low volume + high rating = marketing gap.
-- HAVING clause filters to restaurants with statistical significance (?50 orders).

SELECT 
      r.restaurant_name
    , COUNT(*)                                    AS total_orders
    , SUM(f.price_INR)                            AS total_revenue_INR
    , AVG(f.price_INR)                            AS avg_order_value
    , AVG(f.rating)                               AS avg_rating
    , SUM(f.rating_count)                         AS total_rating_count
    , CAST(SUM(f.price_INR) / COUNT(*) AS DECIMAL(10,2)) AS revenue_per_order
FROM fact_swiggy_orders f
JOIN dim_restaurant r ON f.restaurant_id = r.restaurant_id
GROUP BY r.restaurant_name
HAVING COUNT(*) >= 50
ORDER BY total_revenue_INR DESC;


-- ????????????????????????????????????????????????????????????????????????????
-- [04.2] Category Profitability Analysis
-- ????????????????????????????????????????????????????????????????????????????
-- Calculates revenue contribution per cuisine category.
-- Identifies high-margin categories for promotional investment.
-- Low-margin high-volume categories may benefit from price optimization.

SELECT 
      c.category
    , COUNT(*)                                    AS order_count
    , SUM(f.price_INR)                            AS total_revenue_INR
    , AVG(f.price_INR)                            AS avg_price
    , CAST(
        SUM(f.price_INR) * 100.0 / 
        (SELECT SUM(price_INR) FROM fact_swiggy_orders) 
      AS DECIMAL(5,2))                            AS revenue_share_pct
FROM fact_swiggy_orders f
JOIN dim_category c ON f.category_id = c.category_id
GROUP BY c.category
ORDER BY total_revenue_INR DESC;


-- ????????????????????????????????????????????????????????????????????????????
-- [04.3] City-Level Market Share
-- ????????????????????????????????????????????????????????????????????????????
-- Ranks cities by order volume and calculates their share of total platform activity.
-- Cumulative percentage helps identify if top 5 cities dominate (e.g., 80%+ share).
-- Used for geographic diversification risk assessment.

SELECT 
      l.City
    , COUNT(*)                                    AS city_orders
    , CAST(
        COUNT(*) * 100.0 / 
        (SELECT COUNT(*) FROM fact_swiggy_orders) 
      AS DECIMAL(5,2))                            AS market_share_pct
    , SUM(f.price_INR)                            AS city_revenue_INR
FROM fact_swiggy_orders f
JOIN dim_location l ON f.location_id = l.location_id
GROUP BY l.City
ORDER BY city_orders DESC;


-- ????????????????????????????????????????????????????????????????????????????
-- [04.4] Peak Ordering Hours Analysis
-- ????????????????????????????????????????????????????????????????????????????
-- Groups orders by hour-of-day to identify lunch (12-2pm) and dinner (7-10pm) peaks.
-- Helps optimize delivery fleet allocation and surge pricing windows.
-- Requires Order_Date to include time component (currently date-only in schema).
-- NOTE: This query structure assumes time data exists; modify if not available.

-- Conceptual query — requires DATETIME column with time component:
/*
SELECT 
      DATEPART(HOUR, d.FULL_DATE)               AS order_hour
    , COUNT(*)                                   AS order_count
    , AVG(f.price_INR)                           AS avg_order_value
FROM fact_swiggy_orders f
JOIN dim_date d ON f.date_id = d.date_id
GROUP BY DATEPART(HOUR, d.FULL_DATE)
ORDER BY order_hour;
*/

-- Placeholder using Month as proxy (actual implementation needs time data):
SELECT 
      d.Month_Name
    , COUNT(*)                                   AS order_count
FROM fact_swiggy_orders f
JOIN dim_date d ON f.date_id = d.date_id
GROUP BY d.Month_Name
ORDER BY order_count DESC;


-- ????????????????????????????????????????????????????????????????????????????
-- [04.5] Customer Retention by Restaurant
-- ????????????????????????????????????????????????????????????????????????????
-- Identifies restaurants with highest repeat-order potential.
-- High rating_count relative to order volume suggests strong customer loyalty.
-- Low rating_count despite high orders = one-time transaction pattern (churn risk).

SELECT 
      r.restaurant_name
    , COUNT(*)                                   AS total_orders
    , SUM(f.rating_count)                        AS total_ratings_given
    , CAST(
        SUM(f.rating_count) * 1.0 / COUNT(*) 
      AS DECIMAL(10,2))                          AS ratings_per_order
    , AVG(f.rating)                              AS avg_rating
FROM fact_swiggy_orders f
JOIN dim_restaurant r ON f.restaurant_id = r.restaurant_id
GROUP BY r.restaurant_name
HAVING COUNT(*) >= 30
ORDER BY ratings_per_order DESC;


-- ????????????????????????????????????????????????????????????????????????????
-- [04.6] Price vs Rating Correlation
-- ????????????????????????????????????????????????????????????????????????????
-- Tests hypothesis: "Higher prices lead to lower ratings (customer sensitivity)."
-- Segments orders into price tiers and compares average rating per tier.
-- If avg_rating decreases as price increases, customers perceive poor value.

SELECT 
    CASE 
        WHEN price_INR < 150  THEN 'Budget (< 150)'
        WHEN price_INR < 300  THEN 'Mid-Range (150-299)'
        WHEN price_INR < 500  THEN 'Premium (300-499)'
        ELSE 'Luxury (500+)'
    END AS price_segment,
    COUNT(*)                                     AS order_count,
    AVG(price_INR)                               AS avg_price,
    AVG(rating)                                  AS avg_rating,
    AVG(rating_count)                            AS avg_rating_count
FROM fact_swiggy_orders
WHERE rating IS NOT NULL
GROUP BY 
    CASE 
        WHEN price_INR < 150  THEN 'Budget (< 150)'
        WHEN price_INR < 300  THEN 'Mid-Range (150-299)'
        WHEN price_INR < 500  THEN 'Premium (300-499)'
        ELSE 'Luxury (500+)'
    END
ORDER BY avg_price;


-- ????????????????????????????????????????????????????????????????????????????
-- [04.7] Top Performing Dishes by Revenue
-- ????????????????????????????????????????????????????????????????????????????
-- Ranks individual dishes by total revenue generated.
-- High-revenue dishes should be featured in marketing campaigns.
-- Combines dish name, category, and average rating for strategic insights.

SELECT 
      d.dish_name
    , c.category
    , COUNT(*)                                   AS times_ordered
    , SUM(f.price_INR)                           AS total_revenue_INR
    , AVG(f.price_INR)                           AS avg_dish_price
    , AVG(f.rating)                              AS avg_rating
FROM fact_swiggy_orders f
JOIN dim_dish d     ON f.dish_id     = d.dish_id
JOIN dim_category c ON f.category_id = c.category_id
GROUP BY d.dish_name, c.category
HAVING COUNT(*) >= 20
ORDER BY total_revenue_INR DESC
OFFSET 0 ROWS FETCH NEXT 15 ROWS ONLY;


-- ????????????????????????????????????????????????????????????????????????????
-- [04.8] Geographic Expansion Opportunities (Optimized)
-- ????????????????????????????????????????????????????????????????????????????
-- Filters based on real dataset distribution: 
-- High Ticket (>260 INR) and Room for Volume Growth (<7000 orders).

SELECT 
      l.State
    , l.City
    , COUNT(DISTINCT l.location_id)               AS location_count
    , COUNT(*)                                   AS total_orders
    , AVG(CAST(f.price_INR AS FLOAT))             AS avg_order_value
    , SUM(f.price_INR)                           AS total_revenue_INR
FROM fact_swiggy_orders f
JOIN dim_location l ON f.location_id = l.location_id
GROUP BY l.State, l.City
-- Basado en tus datos: Filtramos ciudades con alto gasto pero volumen medio
HAVING COUNT(*) < 7000 
   AND AVG(CAST(f.price_INR AS FLOAT)) > 260
ORDER BY avg_order_value DESC;


-- ????????????????????????????????????????????????????????????????????????????
-- [04.9] Restaurant Rating Volatility
-- ????????????????????????????????????????????????????????????????????????????
-- Measures consistency of restaurant ratings using MIN/MAX spread.
-- High volatility (max - min > 2) indicates inconsistent food quality or service.
-- Restaurants with narrow spreads deliver predictable experiences (lower churn).

SELECT 
      r.restaurant_name
    , COUNT(*)                                   AS total_orders
    , MIN(f.rating)                              AS min_rating
    , MAX(f.rating)                              AS max_rating
    , MAX(f.rating) - MIN(f.rating)              AS rating_spread
    , AVG(f.rating)                              AS avg_rating
FROM fact_swiggy_orders f
JOIN dim_restaurant r ON f.restaurant_id = r.restaurant_id
WHERE f.rating IS NOT NULL
GROUP BY r.restaurant_name
HAVING COUNT(*) >= 50
ORDER BY rating_spread DESC;


-- ????????????????????????????????????????????????????????????????????????????
-- [04.10] Monthly Growth Rate Analysis
-- ????????????????????????????????????????????????????????????????????????????
-- Calculates month-over-month order volume growth percentage.
-- Negative growth flags declining platform engagement requiring intervention.
-- Positive acceleration (growth rate increasing) indicates viral expansion.

WITH MonthlyOrders AS (
    SELECT 
          d.YEAR
        , d.MONTH
        , d.Month_Name
        , COUNT(*)                               AS monthly_orders
        , SUM(f.price_INR)                       AS monthly_revenue
    FROM fact_swiggy_orders f
    JOIN dim_date d ON f.date_id = d.date_id
    GROUP BY d.YEAR, d.MONTH, d.Month_Name
)
SELECT 
      YEAR
    , Month_Name
    , monthly_orders
    , monthly_revenue
    , LAG(monthly_orders) OVER (ORDER BY YEAR, MONTH) AS prev_month_orders
    , CAST(
        (monthly_orders - LAG(monthly_orders) OVER (ORDER BY YEAR, MONTH)) * 100.0
        / NULLIF(LAG(monthly_orders) OVER (ORDER BY YEAR, MONTH), 0)
      AS DECIMAL(10,2))                          AS growth_rate_pct
FROM MonthlyOrders
ORDER BY YEAR, MONTH;


-- ============================================================================
-- END OF FILE
-- ============================================================================